#!/usr/bin/env python

"""
File Name   : func_nsem_build.py
Description : NSEM models compilation
Usage       : Import this into an external python program such as main.py (i.e. import func_nsem_build)
Date        : 7/6/2020
Contacts    : Coastal Act Team 
              ali.abdolali@noaa.gov, saeed.moghimi@noaa.gov, beheen.m.trimble@gmail.com, andre.vanderwesthuysen@noaa.gov
"""


# standard libs
import os, sys, re
import subprocess, shutil
from pathlib import Path

# local libs
import nsem_utils as nus
import func_nsem_workflow as fnw


class NEMSModel:

    def __init__(self, name, **kwargs):

        # holds kwargs i.e. attributes, petlist, ...
        self.__dict__.update({'Verbosity':'max'})  # default a must
        self.__name = name
        self.__dict__.update(**kwargs)


    @property
    def name(self):
        # i.e. ww3
        return self.__name


    @name.setter
    def name(self, name):
        self.__name = name


    def get_alias(self):
        name = self.name
        return self.__dict__[name.upper()+"_model"]


    def get_attributes(self):
        name = self.name
        return self.__dict__[name.upper()+"_attributes"]


    def get_petlist(self):
        """ gets pets lower and upper index """
        name = self.name
        return self.__dict__[name.upper()+"_petlist_bounds"]




class NEMSConfig():

    """ processes nems, user_module, nems.configure and model_configure file in PRJ_DIR/local_repo """

    def __init__(self, local_repo, node, user_module):

        self.source_dir = local_repo     
        self.node = node
        self.user_module = user_module


    def nems_config(self):
        return os.path.join(self.source_dir, 'nems.configure')


    def model_config(self):
        return os.path.join(self.source_dir, 'model_configure')


    def node(self):
        return self.node

    @property
    def user_module(self):
        return self.__user_module


    @user_module.setter
    def user_module(self, module):
        self.__user_module = os.path.join(self.source_dir,'modulefiles', self.node, module)
        return(self.__user_module)


    def earth_model_names(self):
        return self.__dict__['EARTH_component_list']


    def nems_models(self):
        # holds a list of NEMSModel objects
        return self.__dict__['NEMS_component_list']


    def setup_model_config(self, mc):
        '''creates a new model_config from initial values'''
        model_cf = self.model_config()
        print("\nWriting NEMS model config file %s" %model_cf)
                 
        try:
          lines="""# NEMS model_configure - autogenerated by NSEM at {}
print_esmf:              {}
# The RUN_CONTINUE flag tells us if the RUN step of the
# NEMS component must be called multiple times for ensembles. 
RUN_CONTINUE:            {}
ENS_SPS:                 {}
total_member:            {}
PE_MEMBER01:             {}

start_year:              {}
start_month:             {}
start_day:               {}
start_hour:              {}
start_minute:            {}
start_second:            {}
nhours_fcst:             {}
""".format(nus.now(frmt=3),mc['print_esmf'], mc['run_continue'], mc['ens_sps'],
           mc['total_member'], mc['pe_member01'], mc['start_year'],mc['start_month'],
           mc['start_day'], mc['start_hour'],mc['start_minute'],mc['start_second'],
           mc['nhours_fcst'])       
        except OSError as err:
          print(nus.colory("red", "Error on 'model_configure' values in initialization file - {}\n".format(err)))
          sys.exit(0)
 
        try:
          with open(model_cf, 'w+') as fptr:
            fptr.write(lines)
        except Exception as e:
          print(nus.colory("red", "Error writing to {}\n".format(model_cf)))
       

    def setup_nems_config(self, nc, parmdir):
        '''a copy of nems.configure for current runtype is 
           expected to be in nco parm directory before any build 
           to complete the build requirements '''
        # reading from parm directory, nems.configure.RUN_TYPE
        nems_cfg = os.path.join(parmdir, nc['nems_cfg'])
        print("Looking for pre-defined {}".format(nems_cfg))

        if not nus.found(nems_cfg):
            sys.exit(0)
        
        # copy this to the final location
        dest_file = self.nems_config()
        print("Copying file {} to {}".format(nems_cfg, dest_file))
        shutil.copy(nems_cfg, dest_file)



    def setup_nems_config_old(self, nc):
        '''creates a new nems.configure from initial values'''
        nems_cf = self.nems_config()
        print("Writing NEMS config file {}".format(nems_cf))

        earth_comp = nc['EARTH_component_list']
        earth_str = " ".join([i.strip() for i in earth_comp])

        atm_model = nc['ATM_model']
        atm_str, atm_pet = atm_model
        atm_start, atm_end = atm_pet
        atm_pet_str = str(atm_start) + " " + str(atm_end)

        ocn_model = nc['OCN_model']
        ocn_str, ocn_pet = ocn_model
        ocn_start, ocn_end = ocn_pet
        ocn_pet_str = str(ocn_start) + " " + str(ocn_end)

        wav_model = nc['WAV_model'] 
        wav_str, wav_pet = wav_model
        wav_start, wav_end = wav_pet
        wav_pet_str = str(wav_start) + " " + str(wav_end)

        nwm_model = nc['NWM_model']
        nwm_str, nwm_pet = nwm_model
        nwm_start, nwm_end = nwm_pet
        nwm_pet_str = str(nwm_start) + " " + str(nwm_end)

        run_seq = nc['runSeq']['coupling_interval_sec']



        try:
          lines="""# nems.configure - autogenerated by NSEM at {}
#############################################
####  NEMS Run-Time Configuration File  #####
#############################################

# EARTH #
EARTH_component_list: {}
EARTH_attributes::
  Verbosity = max
::

# ATM #
ATM_model:                      {} 
ATM_petlist_bounds:             {} 
ATM_attributes::
  Verbosity = max
::

# OCN #
OCN_model:                      {}
OCN_petlist_bounds:             {} 
OCN_attributes::
  Verbosity = max
::

# WAV #
WAV_model:                      {}
WAV_petlist_bounds:             {}
WAV_attributes::
  Verbosity = max
::

# HYD #
NWM_model:                      {}
NWM_petlist_bounds:             {}
NWM_attributes::
  Verbosity = max
::

# Run Sequence #
runSeq::
  {}
    ATM -> OCN   :remapMethod=redist
    WAV -> OCN   :remapMethod=redist
    ATM -> NWM   :remapMethod=redist
    WAV -> NWM   :remapMethod=redist
    OCN -> NWM   :remapMethod=bilinear
    NWM -> OCN   :remapMethod=redist
    ATM
    WAV
    OCN
    NWM
  @
::

""".format(nus.now(frmt=3), earth_str, atm_str, atm_pet_str, 
           ocn_str, ocn_pet_str, wav_str, wav_pet_str, 
           nwm_str, nwm_pet_str,
           run_seq
          )
        except OSError as err:
          print(nus.olory("red", "Error on 'model_configure' values in initialization file - {0}\n".format(err)))
          sys.exit(0)

        try:
          with open(nems_cf, 'w+') as fptr:
            fptr.write(lines)
        except Exception as e:
          print(nus.colory("red", "Error writing to {}\n".format(nems_cf)))
        

    def read_model_config(self):

        model_cf = self.model_config()
        print("\nReading NEMS model config file %s" %model_cf)

        try:
          with open(model_cf,'r') as fptr:
            lines = fptr.readlines()
            for line in lines:
              if line.startswith("#") or len(line) < 2:
                continue
              key, value = line.split(":")
              if 'start_year' in key:
                self.start_year = value.strip()
              elif 'start_month' in key:
                self.start_month = value.strip()
              elif 'start_day' in key:
                self.start_day = value.strip()
              elif 'start_hour' in key:
                self.start_hour = value.strip()
              elif 'start_minute' in key:
                self.start_minute = value.strip()
              elif 'start_second' in key:
                self.start_second = value.strip()
              elif 'nhours_fcst' in key:
                self.nhours_fcst = value.strip()
        except Exception as e:
          print(nus.colory("red", "{}\n".format(str(e))))
          sys.exit(-1)

        msg = "Runtime duration since: %s/%s/%s %s:%s:%s for %s hours\n" %(self.start_year,self.start_month,self.start_day,
               self.start_hour, self.start_minute, self.start_second, self.nhours_fcst)
        print(nus.colory("green", msg))



    def get_duration(self):
        date_time_str = "%s/%s/%s %s:%s:%s" %(self.start_day, self.start_month, self.start_year,
                                              self.start_hour, "00", "00")
        self.start_date = nus.to_date(date_time_str, frmt=5)
        self.start_date_str = date_time_str
        return self.start_date, self.start_date_str


    def get_fcst_hours(self):
        return int(self.nhours_fcst)



    def read_nems_config(self):

        nems_cf = self.nems_config()
        print("\nReading NEMS config file %s" %nems_cf)

        try:
          with open(nems_cf,'r') as fptr:
            cnt = 0; sentinel = '::'
            # saves the line # of the "::" in file nems.configure
            indx = []
            lines = fptr.readlines()
            for line in lines:
              cnt += 1
              if line.startswith(sentinel):
                indx.append(cnt)

            # cut each section of the file based on indx
            earth_list = []; model_list = []; seq_list = []

            earth_list = lines[:indx[0]]
            model_list = lines[indx[0]:indx[len(indx)-2]]
            seq_list = lines[indx[len(indx)-2]:]

            # persists newely writen config files into __dic__ 
            self.process_earth_section(earth_list)
            self.process_model_section(model_list)
            self.process_runseq_section(seq_list)

        except Exception as e:
            print(nus.colory("red", "{}\n".format(str(e))))
            sys.exit(-1)



    def get_num_tasks(self):
        """find the larget petlist number and save it as part of NEMSModel
           object for use in Slurm job """
        pl = []
        for model in self.nems_models():
            name = model.name
            petlist = model.get_petlist()
            pl.append(petlist[1])
        return max(pl)



    def print_model(self):
        for model in self.nems_models():
            name = model.name
            petlist = model.get_petlist()
            attrs = model.get_attributes()
            alias = model.get_alias()
            msg = "Model Name      : %s\n" %name
            msg+= "Model Alias     : %s\n" %alias
            msg+= "Model petlist   : %s\n" %petlist
            msg+= "Model attributes: %s\n" %attrs
            print(nus.colory("green", msg))



    def process_earth_section(self, earth_lines):

        sentinel = '::'; i=0

        # lines are not cleaned yet
        lines = [line.strip() for line in earth_lines if len(line) > 1]
        line = lines[i]

        while line:
          #print("Line {}: {}".format(i, line.strip()))

          if re.search('EARTH_component_list', line, re.IGNORECASE) :
            k,v = line.split(":")     # Use v if decided to persists earth models as string instead of list

            models = list(v.split(" "))
            self.__dict__['EARTH_component_list'] = [model.strip() for model in models if len(model) > 1]
            i += 1
            line = lines[i]

          elif re.search('EARTH_attributes', line, re.IGNORECASE) :    # do not use :: becasue it might have space between!
            self.__dict__['EARTH_attributes'] = {}
            i += 1
            line = lines[i]

            while line.find(sentinel) == -1:
              dic = self.__dict__['EARTH_attributes']
              k,v = line.split("=")
              dic[k.strip()] = v.strip()
              self.__dict__['EARTH_attributes'] = dic
              i += 1
              line = lines[i]
            break

          else:
            i += 1
            line = lines[i]

        print("Pocessed EARTH_component_list")
        print(self.__dict__['EARTH_component_list'], "\n")


    def process_model_section(self, model_lines):

      sentinel = '::'; cnt = 0
      lines = [line.strip() for line in model_lines if len(line) > 2]
      line = lines[cnt]


      self.__dict__['NEMS_component_list'] = []
      tmp = []       # array for holding many NEMSModel objects
      i = 0          # counter of number of models in EARTH_component_list

      while( i < len(self.__dict__['EARTH_component_list']) ):
          model = self.__dict__['EARTH_component_list'][i]
          #print("Processing line %d, %s-%s, %d\n" %(cnt, line, model, i))

          if re.search(model+"_model", line, re.IGNORECASE) :   # do not use : becasue it might have space between!
              k,v = line.split(":")
              self.__dict__[model+"_model"] = v.strip()
              # print("1 - ", k, v.strip())
              cnt += 1
              line = lines[cnt]

          elif re.search(model+"_petlist_bounds", line, re.IGNORECASE) :
              k,v = line.split(":")
              v_int = [int(i) for i in list(v.strip().split(" "))]
              self.__dict__[model+"_petlist_bounds"] = v_int
              # print("2 - ", k, v_int)
              cnt += 1
              line = lines[cnt]

          elif re.search(model+"_attributes", line, re.IGNORECASE):
              self.__dict__[model+"_attributes"] = {}
              cnt += 1
              line = lines[cnt]
              while line.find(sentinel) == -1:
                  dic = self.__dict__[model+"_attributes"]
                  k,v = line.split("=")
                  dic[k.strip()] = v.strip()
                  self.__dict__[model+"_attributes"] = dic
                  cnt += 1
                  line = lines[cnt]
              # print("3 - ", k, dic)

              # update before breaking
              kwargs = { model+"_petlist_bounds":self.__dict__[model+"_petlist_bounds"],
                         model+"_attributes":self.__dict__[model+"_attributes"],
                         model+"_model":self.__dict__[model+"_model"]}
              tmp.append(NEMSModel(model,**kwargs))
              i += 1     # go to the next model in the list

          else:
              cnt += 1   # lines with comment or extera
              line = lines[cnt]



      # update before breaking
      self.__dict__['NEMS_component_list'] = tmp

      print("Processed models_component_list")
      self.print_model()



    def process_runseq_section(self, runseq_lines):

      sentinel = '::'; i = 0
      lines = [line.strip() for line in runseq_lines]
      line = lines[i]

      while True :
        # for now put this as common property -TODO
        if re.search('runSeq', line, re.IGNORECASE) :
          self.__dict__["runSeq"] = []
          vals = self.__dict__['runSeq']
          i += 1
          line = lines[i]

          while line.find(sentinel) == -1:
            vals.append(line.strip())
            i += 1
            line = lines[i]

          self.__dict__["runSeq"] = vals
          break
        else:
          i += 1
          line = lines[i]

      print("Processed runSeq")
      print(nus.colory("green", ",    \n".join(self.__dict__['runSeq'])))



class NEMSBuild():

    """ This class creates a build script and copies the build file
        into PRJ_DIR/local_repo, the same level as NEMS source location.
        Then runs the script to compile the system.

        It assumes all model's source are in same level of NEMS.

        # unique prj_dir sturcture is expected to be in this format per NCO standards:
        <PRJ_DIR>/     maps to NCO variable ==> ${NWROOT}
           |--- nsem??                      ==> HOMEmodel (i.e. $NWROOT/model.v X.Y.Z)  TODO - do we need this level??
           |--- sorc/ADC_WW3_NWM_NEMS       ==> sorc
           |     |--- NEMS/   conf/   parm/   modulefiles/   model_configure  nems.configure  nems_env.sh  parm
           |     |--- NWM/  WW3/  ADCIRC/  ATMESH/
           |     |--- esmf-impi-env.sh   build.sh   nems.job
           |     |---
           |     |---
           |--- ecf/   jobs/   scripts/   exec/*   fix/*   parm/*   /ush*

         All stared "*" directories have defined variables in NCO in the form of "VARmodel" (i.e. USHnsem, PARMnsem).
         See files in jobs/ directory where these variables are set.
    """


    def __init__(self, nems_cfg):

        self.nems_cfg = nems_cfg
        self.source_dir = self.nems_cfg.source_dir

        # we need the build.sh script to be available
        self.write_build()


    def write_build(self):

        user_module = self.nems_cfg.user_module
        nems_models = self.nems_cfg.nems_models

        p = os.path.join(self.source_dir,'build.sh')

        junk, modulefile = user_module.split(self.source_dir)

        lines = """#!/bin/bash\n
# Description : Script to compile NSEModel NEMS application 
# Usage       : ./build.sh
# Date        : Autogenerated by NSEM at {}\n
# Contacts    : beheen.m.trimble@noaa.gov
#               saeed.moghimi@noaa.gov
#               andre.vanderwesthuysen@noaa.gov
#               ali.abdolali@noaa.gov

# load modules
source {}

cd NEMS\n""".format(nus.now(2), modulefile[1:])    # remove the '/' from string

        lines += '\n#clean up\n'

        for model in nems_models():
            alias = model.get_alias().upper()
            if not nus.exist(os.path.join(self.source_dir, alias)):
                sys.exit(0)

            lines += 'make -f GNUmakefile distclean_' + \
                      alias + ' COMPONENTS=' + \
                      '"' + alias + '"\n'

        lines += 'make -f GNUmakefile distclean_NEMS COMPONENTS="NEMS"\n'

        lines += '\n#make\n'
        lines += 'make -f GNUmakefile build COMPONENTS="'

        for model in nems_models():
            alias = model.get_alias().upper()
            lines +=  alias+ ' '
        lines = lines[:-1] + '"\n'

        with open(p, 'w') as fptr:
            fptr.write(lines)

        # change mode
        subprocess.call(["chmod", "a+x", p])


        # save
        self.build_script = p
        print("Processed build script %s" %p)



    def setup_libs(self, ini, local_repo):  # TODO
        # for use with NWM compilation - currently expects this to be prepared
        # and to be located in nco parm directory
        nwm_dic = ini.NWM
        nwm_env = nwm_dic['env_files']
        envf = os.path.join(ini.PARMnsem, nwm_env['env'])
        esmf = os.path.join(ini.PARMnsem, nwm_env['esmf'])
        if not nus.found(envf) or not nus.found(esmf):
            sys.exit(0)
        # copy these two files to the final location, NWM home
        # ./compile_nuopc_NoahMP.sh setEnvar.sh esmf-impi-env.sh
        dest_dir = os.path.join(local_repo,"NWM","trunk","NDHMS")
        print("Copying files %s and %s to %s" %(envf, esmf, dest_dir) )
        shutil.copy(envf, dest_dir)
        shutil.copy(esmf, dest_dir)


        """ old code, when NWM setEnvar.sh was in nsem_ini file
 
        setenvar = ???
#!/bin/bash

# WRF-Hydro compile time options

# This is a WRF environment variable. Always set to 1=On for compiling WRF-Hydro.
export WRF_HYDRO=1

# Enhanced diagnostic output for debugging: 0=Off, 1=On.
export HYDRO_D={}

# Spatially distributed parameters for NoahMP: 0=Off, 1=On.
export SPATIAL_SOIL={}

# RAPID model: 0=Off, 1=On.
export WRF_HYDRO_RAPID={}

# WCOSS file units: 0=Off, 1=On.
export NCEP_WCOSS=0

# NWM output metadata: 0=Off, 1=On.
export NWM_META=0

# Streamflow nudging: 0=Off, 1=On.
export WRF_HYDRO_NUDGING={}

???.format(ini.NWM['setEnvar']['hydro_d'], ini.NWM['setEnvar']['spatial_soil'], 
           ini.NWM['setEnvar']['wrf_hydro_rapid'], ini.NWM['setEnvar']['wrf_hydro_nudgging'])

        p = os.path.join(dest_path,"setEnvar_comp.sh")
        with open(p, 'w') as fptr:
            fptr.write(setenvar)
            print("\nProcessed %s" %p)
      
        """


        # setup other libs and add to nems user module, if possible - TO DO
        """ 
        ParMETIS:
        module purge  
        module load intel impi  
        setenv CFLAGS -fPIC  
        make config cc=mpiicc cxx=mpiicc prefix=/path/to/your/parmetis/ | & tee config.out-rr  
        make install | & tee make-install.out-rr  
        This adds libparmetis.a under /path/to/your/parmetis/lib/libparmetis.a
        Set the path to ParMETIS:
        setenv METIS_PATH /path/to/your/parmetis  
        """



    def build_nems_app(self):

        try:
            print("\nStart compiling ............\n")
            subprocess.check_call(['./build.sh'], cwd=self.source_dir, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as err:
            print(nus.colory("red", 'Error in executing build.sh:\n'.format(err)))




class SlurmJob():

    # this class requires information from nems.configure,
    def __init__(self, **kwargs):

        self.__dict__.update(**kwargs)

        if 'error' in kwargs:
            self.error = "j" + kwargs['error'] + ".err.log"
        if 'output' in kwargs:
            self.output = "j" + kwargs['output'] + ".out.log"
        if 'jobname' in kwargs:
            self.jobname = "j" + kwargs['jobname'] + ".job"
        if 'prj_dir' in kwargs:
            self.prj_dir = kwargs['prj_dir']

    def get_sbatch(self):
        return self.sbatch_part


    def print_kw(self):
        print(self.__dict__)


    def write_sbatch(self):

        slurm_file = os.path.join(self.__dict__['slurm_dir'], self.jobname[1:])   # no j in this name, using this in standalone runs not in WCOSS
        self.slurm_job_file = slurm_file

        sbatch_part = """#!/bin/sh -l\n
#SBATCH -A {}
#SBATCH -q {}
#SBATCH -e {}
#SBATCH --output={}
#SBATCH --ignore-pbs
#SBATCH -J {}
#SBATCH --mail-user={}
#SBATCH --ntasks-per-node={}
#SBATCH -N {}
#SBATCH --parsable
#SBATCH -t {}""".format(self.__dict__['account'], self.__dict__['queue'], self.error, self.output,self.jobname,
                        self.__dict__['mailuser'], self.__dict__['ntasks'], self.__dict__['nnodes'], self.__dict__['time'])

        # for use by other classes
        self.sbatch_part = sbatch_part

        lines = """\n\n############################### main - to run: $sbatch {} ##########################
set -x
echo $SLURM_SUBMIT_DIR		# (in Slurm, jobs start in "current dir")
echo $SLURM_JOBID
echo $SLURM_JOB_NAME
echo $SLURM_NNODES
echo $SLURM_TASKS_PER_NODE\n
echo $SLURM_NODELIST		# give you the list of assigned nodes.\n
echo 'STARTING THE JOB AT'
date\n
# change to absolute path of where you pulled the
# NEMS and NEMS Applications. use modules.nems becasue user's
# modulefiles are copied into this with constant name.
cp -fv {}/NEMS/exe/NEMS.x NEMS.x
source {}/NEMS/src/conf/modules.nems
srun ./NEMS.x
date
""".format(self.jobname, self.prj_dir, self.prj_dir )

        with open(slurm_file, 'w') as f:
            f.write(sbatch_part+lines)
        print("\nProcessed slurm job file %s" %slurm_file)



def git_nsem(repo, nco_sorc_dir):
    
    print("\nCloning {} to {}".format(repo, nco_sorc_dir)) 

    # dest_dir is the name part of the repo and so it becomes
    # the location of NEMS and all the models. This is one layer
    # below ROOTDIR, as mentioned in NEMS HOWTO.
    dest_dir = os.path.join(nco_sorc_dir, Path(repo).name)
    if nus.exist(dest_dir):
       print("\nRemoving directory: {}".format(dest_dir))
       try:
           subprocess.run(['rm', '-rf', dest_dir ], check=True)
       except subprocess.CalledProcessError as err:
           print(nus.colory("red", 'Error deleting directory {}\n'.format(err)))

    cmd = ['git', 'clone', '--recursive', repo]      # TO DO - add the user/pass
    try:   
      # must wait to finishe, so check_call or run
      return subprocess.check_call(cmd, cwd=nco_sorc_dir, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
      print(nus.colory("red", "Exception on process, rc=".format(e.returncode)))
    


def nsem_build(args=None):
    """ clones the nsem models from repository into nco sorc directory,
        set up environment and libraries required for build process
        including esmf-impi-env.sh for all models, setEnvar.sh for nwm,
        nems.configure and model_configure for build.sh and nems.job
        build the model in place 
        install the build into com directory
    """
    nco, ini = fnw.nsem_workflow(args)
    sorc_dir = nco.source_dir()           
    parm_dir = nco.parm_dir()

    # git nsem models + nems from repo 
    # conda install gitpython
    repo = ini.repository
    if ini.git_flag:
        git_nsem(repo, sorc_dir)            # TODO - check on the repo version, status, etc


    node = ini.node
    nems = ini.nems
    user_module = nems['user_module']

    mc = ini.model_configure
    nc = ini.nems_configure
    local_repo = os.path.join(sorc_dir, Path(repo).name)    # where we clone nsem models + nems in sorc_dir

    # populate NEMS model and process nems configure files
    # needed for creation of build script
    nems_cf = NEMSConfig(local_repo, node, user_module)
    nems_cf.setup_model_config(mc)
    # nems_cf.setup_nems_config_old(nc)  not used
    nems_cf.setup_nems_config(nc, parm_dir)
    # to test the write 
    nems_cf.read_nems_config()
    nems_cf.read_model_config() 


    # create the build file 
    nems_build = NEMSBuild(nems_cf)                # TODO pickle
    # compile the codes 
    if ini.compile_flag:
        # set libraries before compiling - also make sure any changes to be applied with the flag
        # this is the place where all the models require to have their 
        # compile time dependencies to be preprocessed and to be located in parm dir.
        nems_build.setup_libs(ini, local_repo)      # TODO - metis
        nems_build.build_nems_app()


    # SlurmJob needs update by reading nems.configure,
    # update slurm_args
    ntasks = nems_cf.get_num_tasks()              # not used, remove after testing
    walltime = nems_cf.get_fcst_hours()           # are they the same ??
    start_date, start_date_str = nems_cf.get_duration()
    # print("\n",ntasks, walltime, start_date, start_date_str, local_repo,"\n")
    # note: slurm_source_dir = dest_repo = nems_cf.source_dir, nems_build.source_dir 

    slurm_args = ini.slurm_args
    # update the "TBD" values in nsem_ini.py file
    # slurm_args['ntasks'] = ntasks               # remove after discussion
    slurm_args['slurm_dir'] = local_repo
    slurm_args['prj_dir'] = local_repo
    slurm = SlurmJob(**slurm_args)
    slurm.write_sbatch()
    
    # ecflow file constructions, requires info from both Slurm and NCO
    nco.write_ecf2(slurm)
    nco.write_jjob2()


    # copy nems configs & slurm job and NEMS.x to their destinations
    print("\nCopying files into %s directory..." %(ini.COMIN))
    shutil.copy(os.path.join(local_repo,'nems.configure'), ini.COMIN)   
    shutil.copy(os.path.join(local_repo,'model_configure'), ini.COMIN)   
    shutil.copy(slurm.slurm_job_file, ini.COMIN)
    shutil.copy(os.path.join(local_repo,'NEMS/exe/NEMS.x'), ini.EXECnsem)   
    shutil.copy(os.path.join(local_repo,'NEMS/exe/NEMS.x'), ini.COMIN)   


    # create a importable file of all the environments needed
    nco.write_helper(nems_cf)



